from PyQt5.QtCore import QCoreApplication as QA

class TranslatorStrings:
    @classmethod
    def retranslate(cls):
        cls.strategy_form_title = QA.translate("strategy_form", "Worker Parameters")

        cls.worker_controller = []
        cls.worker_controller.append(QA.translate("worker_controller", "Relative Orders"))
        cls.worker_controller.append(QA.translate("worker_controller", "Staggered Orders"))
        cls.worker_controller.append(QA.translate("worker_controller", "King of the Hill"))
        cls.worker_controller.append(QA.translate("worker_controller", "Worker {0}"))
        cls.worker_controller.append(QA.translate("worker_controller", "Saving the worker will cancel all the current orders.\nAre you sure you want to do this?"))
        cls.worker_controller.append(QA.translate("worker_controller", "Worker name needs to be unique. \"{}\" is already in use."))
        cls.worker_controller.append(QA.translate("worker_controller", "Field \"Base Asset\" does not have a valid asset."))
        cls.worker_controller.append(QA.translate("worker_controller", "Field \"Quote Asset\" does not have a valid asset."))
        cls.worker_controller.append(QA.translate("worker_controller", "Field \"Fee Asset\" does not have a valid asset."))
        cls.worker_controller.append(QA.translate("worker_controller", "Market {}/{} doesn't exist."))
        cls.worker_controller.append(QA.translate("worker_controller", "Account doesn't exist."))
        cls.worker_controller.append(QA.translate("worker_controller", "Private key is invalid."))
        cls.worker_controller.append(QA.translate("worker_controller", "Please use active private key."))

        cls.staggered = []
        cls.staggered.append(QA.translate("staggered_mode", "Mountain"))
        cls.staggered.append(QA.translate("staggered_mode", "Neutral"))
        cls.staggered.append(QA.translate("staggered_mode", "Valley"))      
        cls.staggered.append(QA.translate("staggered_mode", "Buy Slope"))
        cls.staggered.append(QA.translate("staggered_mode", "Sell Slope"))
        cls.staggered.append(QA.translate("staggered", "Strategy mode"))
        cls.staggered.append(QA.translate("staggered", "How to allocate funds and profits. Doesn\'t effect existing orders, only future ones"))
        cls.staggered.append(QA.translate("staggered", "Spread"))
        cls.staggered.append(QA.translate("staggered", "The percentage difference between buy and sell"))
        cls.staggered.append(QA.translate("staggered", "Increment"))
        cls.staggered.append(QA.translate("staggered", "The percentage difference between staggered orders"))
        cls.staggered.append(QA.translate("staggered", "Market center price"))
        cls.staggered.append(QA.translate("staggered", "Begin strategy with center price obtained from the market. Use with mature markets"))
        cls.staggered.append(QA.translate("staggered", "Manual center price"))
        cls.staggered.append(QA.translate("staggered", "In an immature market, give a center price manually to begin with. BASE/QUOTE"))
        cls.staggered.append(QA.translate("staggered", "Lower bound"))
        cls.staggered.append(QA.translate("staggered", "The lowest price (Quote/Base) in the range"))
        cls.staggered.append(QA.translate("staggered", "Upper bound"))
        cls.staggered.append(QA.translate("staggered", "The highest price (Quote/Base) in the range"))
        cls.staggered.append(QA.translate("staggered", "Allow instant fill"))
        cls.staggered.append(QA.translate("staggered", "Allow to execute orders by market"))
        cls.staggered.append(QA.translate("staggered", "Operational depth"))
        cls.staggered.append(QA.translate("staggered", "Order depth to maintain on books"))
        cls.staggered.append(QA.translate("staggered", "Enable fallback logic"))
        cls.staggered.append(QA.translate("staggered", "When unable to close the spread, cancel lowest buy order and place closer buy order"))
        cls.staggered.append(QA.translate("staggered", "Enable Stop Loss"))
        cls.staggered.append(QA.translate("staggered", "Stop Loss order placed when bid price comes near lower bound"))
        cls.staggered.append(QA.translate("staggered", "Stop Loss discount"))
        cls.staggered.append(QA.translate("staggered", "Discount percent, Stop Loss order price = bid price / (1 + discount percent)"))
        cls.staggered.append(QA.translate("staggered", "Stop Loss Amount"))
        cls.staggered.append(QA.translate("staggered", "Relative amount of QUOTE asset to sell at Stop Loss, percentage"))

        cls.koth = []
        cls.koth.append(QA.translate("koth", "Mode"))
        cls.koth.append(QA.translate("koth", "Operational mode"))
        cls.koth.append(QA.translate("koth", "Buy + sell"))
        cls.koth.append(QA.translate("koth", "Buy only"))
        cls.koth.append(QA.translate("koth", "Sell only"))
        cls.koth.append(QA.translate("koth", "Lower bound"))
        cls.koth.append(QA.translate("koth", "Do not place sell orders lower than this bound"))
        cls.koth.append(QA.translate("koth", "Upper bound"))
        cls.koth.append(QA.translate("koth", "Do not place buy orders higher than this bound"))
        cls.koth.append(QA.translate("koth", "Amount (BASE)"))
        cls.koth.append(QA.translate("koth", "Fixed order size for buy orders, expressed in BASE asset, unless \"relative order size\" selected"))
        cls.koth.append(QA.translate("koth", "Amount (QUOTE)"))
        cls.koth.append(QA.translate("koth", "Fixed order size for sell orders, expressed in QUOTE asset, unless \"relative order size\" selected"))
        cls.koth.append(QA.translate("koth", "Relative order size"))
        cls.koth.append(QA.translate("koth", "Amount is expressed as a percentage of the account balance of quote/base asset"))
        cls.koth.append(QA.translate("koth", "Ignore smaller buy orders"))
        cls.koth.append(QA.translate("koth", "Ignore buy orders which are smaller than this threshold (BASE). If unset, use own order size as a threshold"))
        cls.koth.append(QA.translate("koth", "Ignore smaller sell orders"))
        cls.koth.append(QA.translate("koth", "Ignore sell orders which are smaller than this threshold (QUOTE). If unset, use own order size as a threshold"))
        cls.koth.append(QA.translate("koth", "Min order lifetime"))
        cls.koth.append(QA.translate("koth", "Minimum order lifetime before order reset, seconds"))

        cls.settings = []
        cls.settings.append(QA.translate("settings", "Restore Defaults"))
        cls.settings.append(QA.translate("settings", "Discard"))
        cls.settings.append(QA.translate("settings", "Save"))

        cls.settings_controller = []
        cls.settings_controller.append(QA.translate("settings_controller", "Unsaved changes detected; Node added."))
        cls.settings_controller.append(QA.translate("settings_controller", "Unsaved changes detected; List order has changed."))
        cls.settings_controller.append(QA.translate("settings_controller", "Unsaved changes detected; Node removed."))
        cls.settings_controller.append(QA.translate("settings_controller", "Settings successfully saved!"))
        cls.settings_controller.append(QA.translate("settings_controller", "Can\'t save empty list"))
        cls.settings_controller.append(QA.translate("settings_controller", "Restored default nodes. Remember to save changes!"))

        cls.worker_item = []
        cls.worker_item.append(QA.translate("worker_item", "Starting worker"))
        cls.worker_item.append(QA.translate("worker_item", "TURN WORKER OFF"))
        cls.worker_item.append(QA.translate("worker_item", "Pausing worker"))
        cls.worker_item.append(QA.translate("worker_item", "TURN WORKER ON"))
        cls.worker_item.append(QA.translate("worker_item", "Are you sure you want to remove worker \"{}\"?"))

        cls.staggered_orders = []
        cls.staggered_orders.append(QA.translate("staggered_orders", "Spread must be greater than increment by at least {}, refusing to work because worker will make losses"))
        cls.staggered_orders.append(QA.translate("staggered_orders", "Operational depth should be at least 2 orders"))
        cls.staggered_orders.append(QA.translate("staggered_orders", "Using manual center price because of no sell or buy orders"))
        cls.staggered_orders.append(QA.translate("staggered_orders", "Cannot calculate center price on empty market, please set it manually"))
        cls.staggered_orders.append(QA.translate("staggered_orders", "Virtual orders restored"))
        cls.staggered_orders.append(QA.translate("staggered_orders", "Placed orders: %s"))
        cls.staggered_orders.append(QA.translate("staggered_orders", "Raising check interval up to {} seconds to reduce CPU usage"))
        cls.staggered_orders.append(QA.translate("staggered_orders", "Reducing check interval to {} seconds because of changed balances"))
        cls.staggered_orders.append(QA.translate("staggered_orders", "Free balances are not changing, bootstrap is off and target spread is not reached. Cancelling lowest buy order as a fallback"))
        cls.staggered_orders.append(QA.translate("staggered_orders", "Executing Stop Loss, selling {:.{prec}f} {} @ {:.8f}"))
        cls.staggered_orders.append(QA.translate("staggered_orders", "Using {:.2%} of QUOTE balance ({:.{prec}f} {})"))
        cls.staggered_orders.append(QA.translate("staggered_orders", "Using {:.2%} of BASE balance ({:.{prec}f} {})"))
        cls.staggered_orders.append(QA.translate("staggered_orders", "Dumping initial orders into db"))
        cls.staggered_orders.append(QA.translate("staggered_orders", "Removing initial orders from the db"))
        cls.staggered_orders.append(QA.translate("staggered_orders", "Cancelling sell order outside range: {:.8f}"))
        cls.staggered_orders.append(QA.translate("staggered_orders", "Cancelling buy order outside range: {:.8f}"))
        cls.staggered_orders.append(QA.translate("staggered_orders", "Batch cancel failed, failing back to cancelling single order"))
        cls.staggered_orders.append(QA.translate("staggered_orders", "No real orders, purging old virtual orders"))
        cls.staggered_orders.append(QA.translate("staggered_orders", "Loading virtual orders from database"))
        cls.staggered_orders.append(QA.translate("staggered_orders", "Recreating virtual orders"))
        cls.staggered_orders.append(QA.translate("staggered_orders", "Purging virtual sell orders because of no real sell orders"))
        cls.staggered_orders.append(QA.translate("staggered_orders", "Loading virtual buy orders from database"))
        cls.staggered_orders.append(QA.translate("staggered_orders", "Purging virtual buy orders because of no real buy orders"))
        cls.staggered_orders.append(QA.translate("staggered_orders", "Loading virtual sell orders from database"))
        cls.staggered_orders.append(QA.translate("staggered_orders", "Replacing real buy order with virtual"))
        cls.staggered_orders.append(QA.translate("staggered_orders", "Replacing real sell order with virtual"))
        cls.staggered_orders.append(QA.translate("staggered_orders", "Replacing virtual buy order with real order"))
        cls.staggered_orders.append(QA.translate("staggered_orders", "Error broadcasting trx:"))
        cls.staggered_orders.append(QA.translate("staggered_orders", "Replacing virtual sell order with real order"))
        cls.staggered_orders.append(QA.translate("staggered_orders", "Center price change is {:.2%}, need to store balance data"))
        cls.staggered_orders.append(QA.translate("staggered_orders", "Storing balance data at center price {:.8f}"))
        cls.staggered_orders.append(QA.translate("staggered_orders", "Need to allocate {}: {}"))
        cls.staggered_orders.append(QA.translate("staggered_orders", "Turning bootstrapping off: actual_spread > target_spread, we have free balances and cannot allocate them normally 3 times in a row"))
        cls.staggered_orders.append(QA.translate("staggered_orders", "Placing closer {} order; actual spread: {:.4%}, target + increment: {:.4%}"))
        cls.staggered_orders.append(QA.translate("staggered_orders", "Using stored opposite order"))
        cls.staggered_orders.append(QA.translate("staggered_orders", "Using real opposite order"))
        cls.staggered_orders.append(QA.translate("staggered_orders", "Limiting {} order by opposite order: {:.{prec}f} {}"))
        cls.staggered_orders.append(QA.translate("staggered_orders", "Partially filled order on own side, reserving funds to replace: {:.{prec}f} {}"))
        cls.staggered_orders.append(QA.translate("staggered_orders", "Partially filled order on opposite side, reserving funds for next {} order: {:.{prec}f} {}"))
        cls.staggered_orders.append(QA.translate("staggered_orders", "Increasing sizes of {} orders"))
        cls.staggered_orders.append(QA.translate("staggered_orders", "Placing further order than current furthest {} order"))
        cls.staggered_orders.append(QA.translate("staggered_orders", "Cancelling dust order at opposite side, placing closer {} order"))
        cls.staggered_orders.append(QA.translate("staggered_orders", "Placing first {} order"))
        cls.staggered_orders.append(QA.translate("staggered_orders", "Not enough balance to increase {} order at price {:.8f}: {:.{prec}f}/{:.{prec}f} {}"))
        cls.staggered_orders.append(QA.translate("staggered_orders", "Pre-increasing {} order at price {:.8f} from {:.{prec}f} to {:.{prec}f} {}"))
        cls.staggered_orders.append(QA.translate("staggered_orders", "Increasing {} order at price"))
        cls.staggered_orders.append(QA.translate("staggered_orders", "Cancelling {} order in increase_order_sizes(); mode: {}, amount: {}, price: {:.8f}"))
        cls.staggered_orders.append(QA.translate("staggered_orders", "Partially filled {} order: {} {} @ {:.8f}, filled: {:.2%}"))
        cls.staggered_orders.append(QA.translate("staggered_orders", "Replacing partially filled {} order"))
        cls.staggered_orders.append(QA.translate("staggered_orders", "Unable to replace partially filled {} order: avail/needed: {:.{prec}f}/{:.{prec}f} {}"))
        cls.staggered_orders.append(QA.translate("staggered_orders", "Only own_asset_limit or opposite_asset_limit should be specified"))
        cls.staggered_orders.append(QA.translate("staggered_orders", "Refusing to place an order which crosses lowest ask"))
        cls.staggered_orders.append(QA.translate("staggered_orders", "Refusing to place buy order which crosses upper bound"))
        cls.staggered_orders.append(QA.translate("staggered_orders", "Refusing to place an order which crosses highest bid"))
        cls.staggered_orders.append(QA.translate("staggered_orders", "Refusing to place sell order which crosses lower bound"))
        cls.staggered_orders.append(QA.translate("staggered_orders", "Limiting {} order amount to available asset balance: {:.{prec}f} {}"))
        cls.staggered_orders.append(QA.translate("staggered_orders", "Not enough balance to place closer {} order; need/avail: {:.{prec}f}/{:.{prec}f}"))
        cls.staggered_orders.append(QA.translate("staggered_orders", "Correcting closer order amount to minimal allowed"))
        cls.staggered_orders.append(QA.translate("staggered_orders", "Not enough balance to place minimal allowed order: {:.{prec}f}/{:.{prec}f} {}"))
        cls.staggered_orders.append(QA.translate("staggered_orders", "Placing virtual closer buy order"))
        cls.staggered_orders.append(QA.translate("staggered_orders", "Placing closer buy order"))
        cls.staggered_orders.append(QA.translate("staggered_orders", "Placing virtual closer sell order"))
        cls.staggered_orders.append(QA.translate("staggered_orders", "Placing closer sell order"))
        cls.staggered_orders.append(QA.translate("staggered_orders", "Not enough balance to place further {} order; need/avail: {:.{prec}f}/{:.{prec}f}"))
        cls.staggered_orders.append(QA.translate("staggered_orders", "Correcting further order amount to minimal allowed"))
        cls.staggered_orders.append(QA.translate("staggered_orders", "Placing virtual further buy order"))
        cls.staggered_orders.append(QA.translate("staggered_orders", "Placing further buy order"))
        cls.staggered_orders.append(QA.translate("staggered_orders", "Placing virtual further sell order"))
        cls.staggered_orders.append(QA.translate("staggered_orders", "Placing further sell order"))
        cls.staggered_orders.append(QA.translate("staggered_orders", "Not placing highest sell order because price will exceed higher bound. Market center price: {:.8f}, closest order price: {:.8f}, upper_bound: {:.8f}"))
        cls.staggered_orders.append(QA.translate("staggered_orders", "Placing increased order because calculated size is less than allowed minimum"))
        cls.staggered_orders.append(QA.translate("staggered_orders", "Insufficient balance to place sell order"))
        cls.staggered_orders.append(QA.translate("staggered_orders", "Not placing lowest buy order because price will exceed lower bound. Market center price: {:.8f}, closest order price: {:.8f}, lower bound: {:.8f}"))
        cls.staggered_orders.append(QA.translate("staggered_orders", "Insufficient balance to place buy order"))
        cls.staggered_orders.append(QA.translate("staggered_orders", "Too small order, base: {:.8f}/{:.8f}, quote: {}/{}"))
        cls.staggered_orders.append(QA.translate("staggered_orders", "Placing a virtual buy order with {:.{prec}f} {} @ {:.8f}"))
        cls.staggered_orders.append(QA.translate("staggered_orders", "Placing a virtual sell order with {:.{prec}f} {} @ {:.8f}"))

        cls.decorators = QA.translate("decorators", "Maintenance execution took: {:.2f} seconds")

        cls.bitshares_engine = []
        cls.bitshares_engine.append(QA.translate("bitshares_engine", "Unable to cancel order"))
        cls.bitshares_engine.append(QA.translate("bitshares_engine", "Unable to cancel order(s), private key missing."))
        cls.bitshares_engine.append(QA.translate("bitshares_engine", "Canceling all account orders"))
        cls.bitshares_engine.append(QA.translate("bitshares_engine", "Canceling all orders on market {}/{}"))
        cls.bitshares_engine.append(QA.translate("bitshares_engine", "Orders canceled"))
        cls.bitshares_engine.append(QA.translate("bitshares_engine", "Trying to buy 0"))
        cls.bitshares_engine.append(QA.translate("bitshares_engine", "Insufficient buy balance, needed {} {}"))
        cls.bitshares_engine.append(QA.translate("bitshares_engine", "Placing a buy order with {:.{prec}f} {} @ {:.8f}"))
        cls.bitshares_engine.append(QA.translate("bitshares_engine", "Placed buy order {}"))
        cls.bitshares_engine.append(QA.translate("bitshares_engine", "Trying to sell 0"))
        cls.bitshares_engine.append(QA.translate("bitshares_engine", "Insufficient sell balance, needed {} {}"))
        cls.bitshares_engine.append(QA.translate("bitshares_engine", "Placing a sell order with {:.{prec}f} {} @ {:.8f}"))
        cls.bitshares_engine.append(QA.translate("bitshares_engine", "Placed sell order {}"))
        cls.bitshares_engine.append(QA.translate("bitshares_engine", "Ref block num: {}, prefix: {}"))
        cls.bitshares_engine.append(QA.translate("bitshares_engine", "Ignoring: \'{}\'"))
        cls.bitshares_engine.append(QA.translate("bitshares_engine", "retrying on \'{}\'"))
        cls.bitshares_engine.append(QA.translate("bitshares_engine", "Too much difference between node block time and trx expiration, please change the node. Block time: {}, local time: {}"))
        cls.bitshares_engine.append(QA.translate("bitshares_engine", "Too much difference between node block time and trx expiration, switching node"))
        cls.bitshares_engine.append(QA.translate("bitshares_engine", "Insufficient balance of fee asset"))
        cls.bitshares_engine.append(QA.translate("bitshares_engine", "Got tapos_block_summary exception, switching node"))
        cls.bitshares_engine.append(QA.translate("bitshares_engine", "Old: {}, new: {}"))
        cls.bitshares_engine.append(QA.translate("bitshares_engine", "Partially filled {} order: {} {} @ {:.8f}, filled: {:.2%}"))

        cls.bitshares_feed = []
        cls.bitshares_feed.append(QA.translate("bitshares_feed", "Market has no buy orders."))
        cls.bitshares_feed.append(QA.translate("bitshares_feed", "Market has no sell orders."))
        cls.bitshares_feed.append(QA.translate("bitshares_feed", "Cannot estimate center price, there is no highest bid."))
        cls.bitshares_feed.append(QA.translate("bitshares_feed", "Cannot estimate center price, there is no lowest ask."))
        cls.bitshares_feed.append(QA.translate("bitshares_feed", "Center price in get_market_center_price: {:.8f} "))

        cls.base = QA.translate("base", "Got asset which is not used by this worker")

        cls.echo = []
        cls.echo.append(QA.translate("echo", "Order matched: {}"))
        cls.echo.append(QA.translate("echo", "Order placed: {}"))
        cls.echo.append(QA.translate("echo", "Call update: {}"))
        cls.echo.append(QA.translate("echo", "Market update: {}"))
        cls.echo.append(QA.translate("echo", "New block: {}"))
        cls.echo.append(QA.translate("echo", "Account: {}"))

        cls.king_of_the_hill = []
        cls.king_of_the_hill.append(QA.translate("king_of_the_hill", "Initializing {}..."))
        cls.king_of_the_hill.append(QA.translate("king_of_the_hill", "{} initialized."))
        cls.king_of_the_hill.append(QA.translate("king_of_the_hill", "Own {} order filled too much, resetting"))
        cls.king_of_the_hill.append(QA.translate("king_of_the_hill", "Detected an order above ours"))
        cls.king_of_the_hill.append(QA.translate("king_of_the_hill", "Too much gap between our top buy order and next further order: %s"))
        cls.king_of_the_hill.append(QA.translate("king_of_the_hill", "Too much gap between our top sell order and further order: %s"))
        cls.king_of_the_hill.append(QA.translate("king_of_the_hill", "Own {} order filled, placing a new one"))
        cls.king_of_the_hill.append(QA.translate("king_of_the_hill", "Top sell price to be higher {:.8f} < lower bound {:.8f}"))
        cls.king_of_the_hill.append(QA.translate("king_of_the_hill", "Top sell price to be higher: {:.8f}"))
        cls.king_of_the_hill.append(QA.translate("king_of_the_hill", "Top buy price to be higher {:.8f} > upper bound {:.8f}"))
        cls.king_of_the_hill.append(QA.translate("king_of_the_hill", "Top buy price to be higher: {:.8f}"))
        cls.king_of_the_hill.append(QA.translate("king_of_the_hill", "Margin call on market {} at price {:.8f}"))
        cls.king_of_the_hill.append(QA.translate("king_of_the_hill", "Correcting top sell price to {:.8f}"))
        cls.king_of_the_hill.append(QA.translate("king_of_the_hill", "Correcting top buy price to {:.8f}"))
        cls.king_of_the_hill.append(QA.translate("king_of_the_hill", "Market has empty orderbook"))
        cls.king_of_the_hill.append(QA.translate("king_of_the_hill", "Cannot determine top buy price, correct your bounds and/or ignore thresholds"))
        cls.king_of_the_hill.append(QA.translate("king_of_the_hill", "Not placing %s order in \"both\" mode due to insufficient balance"))
        cls.king_of_the_hill.append(QA.translate("king_of_the_hill", "Cannot place {} order with 0 amount. Adjust your settings or add balance"))
        cls.king_of_the_hill.append(QA.translate("king_of_the_hill", "Amount for {} order is too small"))
        cls.king_of_the_hill.append(QA.translate("king_of_the_hill", "Cannot place top {} order because it will cross the opposite side; increase your order size to lower price step; my top price: {:.8f}, lowest ast: {:.8f}"))
        cls.king_of_the_hill.append(QA.translate("king_of_the_hill", "Cannot determine top sell price, correct your bounds and/or ignore thresholds"))
        cls.king_of_the_hill.append(QA.translate("king_of_the_hill", "Cannot place top {} order because it will cross the opposite side; increase your order size to lower price step; my top price: {:.8f}, highest bid: {:.8f}"))
        cls.king_of_the_hill.append(QA.translate("king_of_the_hill", "Failed to place {} order"))

        cls.relative_orders = []
        cls.relative_orders.append(QA.translate("relative_orders", "Initializing Relative Orders"))
        cls.relative_orders.append(QA.translate("relative_orders", "\"Reset orders on center price change\" requires \"Dynamic Center Price\""))
        cls.relative_orders.append(QA.translate("relative_orders", "Market is empty and using dynamic market parameters. Waiting for market change..."))
        cls.relative_orders.append(QA.translate("relative_orders", "\"Reset orders on center price change\" is active, placing fresh orders"))
        cls.relative_orders.append(QA.translate("relative_orders", "Checking orders by tick threshold"))
        cls.relative_orders.append(QA.translate("relative_orders", "inside get_external_mcp, exchange: {} "))
        cls.relative_orders.append(QA.translate("relative_orders", "market: {}  "))
        cls.relative_orders.append(QA.translate("relative_orders", "PriceFeed: {}"))
        cls.relative_orders.append(QA.translate("relative_orders", "Substitute USD/USDT center price: {}"))
        cls.relative_orders.append(QA.translate("relative_orders", "Consolidated center price: {}"))
        cls.relative_orders.append(QA.translate("relative_orders", "Using center price from external source: {:.8f}"))
        cls.relative_orders.append(QA.translate("relative_orders", "Failed to obtain center price from external source"))
        cls.relative_orders.append(QA.translate("relative_orders", "Using center price from last trade: {:.8f}"))
        cls.relative_orders.append(QA.translate("relative_orders", "Failed to obtain last trade price"))
        cls.relative_orders.append(QA.translate("relative_orders", "Using market center price (failed to obtain last trade): {:.8f}"))
        cls.relative_orders.append(QA.translate("relative_orders", "Failed to obtain center price from market"))
        cls.relative_orders.append(QA.translate("relative_orders", "Using market center price: {:.8f} with depth: {:.{prec}f}"))
        cls.relative_orders.append(QA.translate("relative_orders", "Failed to obtain depthted center price"))
        cls.relative_orders.append(QA.translate("relative_orders", "Using market center price: {:.8f}"))
        cls.relative_orders.append(QA.translate("relative_orders", "Center price after offsets calculation: {:.8f}"))
        cls.relative_orders.append(QA.translate("relative_orders", "No center price calculated"))
        cls.relative_orders.append(QA.translate("relative_orders", "Starting to update orders"))
        cls.relative_orders.append(QA.translate("relative_orders", "Done placing orders"))
        cls.relative_orders.append(QA.translate("relative_orders", "Could not find order on the market, it was filled, expired or cancelled"))
        cls.relative_orders.append(QA.translate("relative_orders", "Partially filled order detected, filled {:.2%}"))
        cls.relative_orders.append(QA.translate("relative_orders", "Center price changed, updating orders. Diff: {:.2%}"))
        cls.relative_orders.append(QA.translate("relative_orders", "Orders correct on market"))
        cls.relative_orders.append(QA.translate("relative_orders", "Cannot estimate center price, there is no highest bid."))
        cls.relative_orders.append(QA.translate("relative_orders", "Cannot estimate center price, there is no lowest ask."))

        cls.strategy_template = []
        cls.strategy_template.append(QA.translate("strategy_template", "Initializing {}..."))
        cls.strategy_template.append(QA.translate("strategy_template", "{} initialized."))
        cls.strategy_template.append(QA.translate("strategy_template", "Starting {}"))

        cls.worker_list = []
        cls.worker_list.append(QA.translate("worker_list", "ver {} - Node disconnected"))
        cls.worker_list.append(QA.translate("worker_list", "Connecting to Bitshares..."))
        cls.worker_list.append(QA.translate("worker_list", "ver {} - Coudn\'t connect to Bitshares. Please use different node(s) and retry."))
        cls.worker_list.append(QA.translate("worker_list", "ver {} - Node(s) not found. Please add node(s) from settings."))
        cls.worker_list.append(QA.translate("worker_list", "ver {} - Node delay: - ms"))
        cls.worker_list.append(QA.translate("worker_list", "Closing app..."))
        cls.worker_list.append(QA.translate("worker_list", "ver {} - Node delay: {:.2f}ms - node: {}"))